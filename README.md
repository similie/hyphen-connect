# HyphenConnect

HyphenConnect is an open-source library designed to simplify cloud connectivity for ESP32-based devices. This powerful tool provides seamless integration with Wi-Fi and cellular networks, enabling developers to create robust and reliable IoT applications. With its extensible architecture and support for secure function calling and variable sharing, HyphenConnect empowers users to build innovative solutions that connect resources across various hardware platforms.

## Features

- Dual Connectivity: Effortlessly switch between Wi-Fi and cellular networks to maintain robust connections.
- Cloud Integration: Simplifies publishing and subscribing to cloud-based topics.
- Extensibility: Easily register custom functions and variables for remote invocation and monitoring.
- Open Source: Licensed under the MIT License, encouraging community contributions and collaboration.

### Getting Started

#### Prerequisites

- Hardware: ESP32 development board.
- Software: Arduino IDE with ESP32 board support installed.
- Cellular: for cellular support you'll need a TinyGSM compatible module, our test setup uses a [Lilygo T-PCIE](https://www.lilygo.cc/products/a-t-pcie) and the SIM7600G-H

#### Installation

1. Clone the Repository: git clone https://github.com/similie/HyphenConnect.git
2. Include the Library in Your Project: Copy the HyphenConnect folder into your Arduino libraries directory.

#### Usage

Here’s an example of how to use HyphenConnect in your project:

```cpp

#include "HyphenConnect.h"
Ticker tick;
HyphenConnect hyphen(ConnectionType::WIFI_PREFERRED);
bool payloadReady = false;
long ticker = 0;

String sendMessage()
{
    JsonDocument doc;
    doc["message"] = "Hello from HyphenConnect";
    doc["id"] = DEVICE_PUBLIC_ID;
    String send;
    serializeJson(doc, send);
    return send;
}

void sendPayload()
{
    payloadReady = false;
    if (!hyphen.isConnected())
    {
        Log.noticeln("Not connected to a network");
        return;
    }

    if (!hyphen.publishTopic("Hy/Post/Message", sendMessage()))
    {
        Log.noticeln("Failed to publish message");
        return;
    }
    Log.noticeln("Published message");
}

int sendTickerValuePlusOne(const char *params)
{
    Log.notice(F("Calling all functions %s" CR), params);
    return 1 + ticker;
}

void setup()
{

    while (!hyphen.setup(LOG_LEVEL_VERBOSE))
        ;
    hyphen.subscribe("Hy/Post/Config", [](const char *topic, const char *payload)
                     {
        Log.notice(F("Received message on topic: %s" CR), topic);
        Log.notice(F("Payload: %s" CR), payload); });
    // here we register a function
    hyphen.function("sendTickerValuePlusOne", sendTickerValuePlusOne);
    // and we register our tickerValue as a variable
    hyphen.variable("tickerValue", &ticker);
    // our job interval
    tick.attach(10, []()
                { payloadReady = true; });
}

void loop()
{
    hyphen.loop();
    if (!payloadReady)
    {
        return;
    }
    sendPayload();
    ticker++;
}
```

This example demonstrates how to:
• Initialize HyphenConnect with a preferred connection type.
• Publish messages to a specific topic.
• Subscribe to topics and handle incoming messages.
• Register custom functions and variables for remote access.

### MQTT Default Topics Commands

```javascript
/*
* The call ID is a unique identifier for each call. It should be generated by the calling application and sent to the request.
*/
// This is used to call a function on the device.
"Hy/Post/Function/<DeviceId>/<FunctionName>/<CallId>"
// On startup, the device will send the functions that it supports. Your application should retain these. Note the devices sends these one at a time
"Hy/Post/Function/Register/<DeviceId>"
// This topic will receive the function results
"Hy/Post/Function/Result/<DeviceId>/<FunctionName>/<CallId>"
// The JSON results are as follows:
{
  "value": int,
  "key": "<FunctionName>",
  "id": "<DeviceId>",
  "request": "<CallId>" // this can be anything
}
// This is used to call a function on the device.
"Hy/Post/Variable/<DeviceId>/<VariableName>/<CallId>"
// On startup, the device will send the variables that it supports. These can be stored by your application. Note the device sends these one at a time
"Hy/Post/Variable/Register/<DeviceId>"
// This topic will receive the variable value
"Hy/Post/Function/Variable/<DeviceId>/<VariableName>/<CallId>"
// The JSON results are as follows:
{
  "value": any, // variable value
  "key": "<VariableName>",
  "id": "<DeviceId>",
  "request": "<CallId>" // this can be anything
}
```

### Available Macros

```cpp
// The tiny GSM Modem Type. This is used for the TinyGsm library.
TINY_GSM_MODEM_SIM7600
// If you are using the a cellular modem, you will need to set this to the APN of your cellular network
CELLULAR_APN "internet"
// If you have a SIM pim
GSM_SIM_PIN ""
// MQTT Endpoint
MQTT_IOT_ENDPOINT ""
// MQTT Port
MQTT_IOT_PORT 8883
// Device ID, this should be unique for each device.
DEVICE_PUBLIC_ID=""
// We control a light on the device to indicate the connection
LED_PIN 12
// What is the Serial Baud
UART_BAUD 115200
// What is the Serial TX pin to connect cellular
CELLULAR_PIN_TX 27
// What is the Serial RX pin to connect cellular
CELLULAR_PIN_RX 26
// Auxillary Power Pin. This Pin is the PWR-KEY of the SIM7600
CELLULAR_POWER_PIN_AUX 4
// What is the pin for controlling the cellular power
CELLULAR_POWER_PIN 25
// What is the pin for controlling when cellular is on or off
CELLULAR_IND_PIN=36
// The default WiFi SSID. In future iteration, we will support connecting to
// the device via Bluetooth to configure the wifi.
DEFAULT_WIFI_SSID ""
// The default WiFi password.
DEFAULT_WIFI_PASS ""
// What is the base topic for all messages.
MQTT_TOPIC_BASE "Hy/"
// The CA certificate to use when connecting to the MQTT broker.
MQTT_CA_CERTIFICATE "-----BEGIN CERTIFICATE-----\nMIIDWTCCAkGgAwIBAgIUI7z\n-----END CERTIFICATE-----\n"
// The device certificate to use when connecting to the MQTT broker.
MQTT_DEVICE_CERTIFICATE "-----BEGIN CERTIFICATE-----\nMIIDWTCCAkGgAwIBAgIUI7z\n-----END CERTIFICATE-----\n"
// The device private key to use when connecting to the MQTT broker.
MQTT_DEVICE_PRIVATE_KEY "-----BEGIN RSA PRIVATE KEY-----\nMIIDWTCCAkGgAwIBAgIUI7z\n-----END RSA PRIVATE KEY-----\n"
// Instead of using the above certificates, you can also use a certificate and private key file directly. In PlatformIO these files exist in the `data` folder.
MQTT_CA_CERTIFICATE_NAME "/root-ca.pem"
MQTT_DEVICE_CERTIFICATE_NAME "/device-cert.pem"
MQTT_DEVICE_PRIVATE_KEY_NAME="/private-key.pem"
```

### About Similie

Similie is a technology company based out of Timor-Leste, dedicated to developing innovative solutions that support international development initiatives and climate-change adaption. Our mission is to harness the power of technology to drive positive change and improve lives around the world. With a focus on sustainability, community engagement, and social impact, we strive to create products and services that make a real difference in people's lives.

### Contributions

Contributions are welcome! This library is still in the early stages of development. Please be aware that in production, there might be stability issues. We are actively working on adding LoRaWAN support. If you’re interested in contributing, please fork the repository and submit a pull request.

### License

This project is licensed under the MIT License. See the LICENSE file for details.

### Acknowledgments

Special thanks to the open-source community for their invaluable contributions and support. Similie proudly produces open source technology that aims to benefit those impacted by the challenges of climate change.
